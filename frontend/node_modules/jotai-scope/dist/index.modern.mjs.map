{"version":3,"file":"index.modern.mjs","sources":["../src/createIsolation.tsx","../src/ScopeProvider/scope.ts","../src/ScopeProvider/patchedStore.ts","../src/ScopeProvider/ScopeProvider.tsx"],"sourcesContent":["import { createContext, useContext, useRef } from 'react';\nimport type { ReactNode } from 'react';\nimport { createStore } from 'jotai/vanilla';\nimport type { WritableAtom } from 'jotai/vanilla';\nimport {\n  useAtom as useAtomOrig,\n  useAtomValue as useAtomValueOrig,\n  useSetAtom as useSetAtomOrig,\n  useStore as useStoreOrig,\n} from 'jotai/react';\nimport { useHydrateAtoms } from 'jotai/react/utils';\n\ntype Store = ReturnType<typeof createStore>;\ntype AnyWritableAtom = WritableAtom<unknown, any[], any>;\n\nexport function createIsolation() {\n  const StoreContext = createContext<Store | null>(null);\n\n  function Provider({\n    store,\n    initialValues = [],\n    children,\n  }: {\n    store?: Store;\n    initialValues?: Iterable<readonly [AnyWritableAtom, unknown]>;\n    children: ReactNode;\n  }) {\n    const storeRef = useRef(store);\n    if (!storeRef.current) {\n      storeRef.current = createStore();\n    }\n    useHydrateAtoms(initialValues as any, { store: storeRef.current });\n    return (\n      <StoreContext.Provider value={storeRef.current}>\n        {children}\n      </StoreContext.Provider>\n    );\n  }\n\n  const useStore = ((options?: any) => {\n    const store = useContext(StoreContext);\n    if (!store) throw new Error('Missing Provider from createIsolation');\n    return useStoreOrig({ store, ...options });\n  }) as typeof useStoreOrig;\n\n  const useAtom = ((anAtom: any, options?: any) => {\n    const store = useStore();\n    return useAtomOrig(anAtom, { store, ...options });\n  }) as typeof useAtomOrig;\n\n  const useAtomValue = ((anAtom: any, options?: any) => {\n    const store = useStore();\n    return useAtomValueOrig(anAtom, { store, ...options });\n  }) as typeof useAtomValueOrig;\n\n  const useSetAtom = ((anAtom: any, options?: any) => {\n    const store = useStore();\n    return useSetAtomOrig(anAtom, { store, ...options });\n  }) as typeof useSetAtomOrig;\n\n  return { Provider, useStore, useAtom, useAtomValue, useSetAtom };\n}\n","import { atom, type Atom } from 'jotai';\nimport type { AnyAtomFamily, AnyAtom, AnyWritableAtom, Scope } from './types';\n\nconst globalScopeKey: { name?: string } = {};\nif (process.env.NODE_ENV !== 'production') {\n  globalScopeKey.name = 'unscoped';\n  globalScopeKey.toString = toString;\n}\n\ntype GlobalScopeKey = typeof globalScopeKey;\n\nexport function createScope(\n  atoms: Set<AnyAtom>,\n  atomFamilies: Set<AnyAtomFamily>,\n  parentScope: Scope | undefined,\n  scopeName?: string | undefined,\n): Scope {\n  const explicit = new WeakMap<AnyAtom, [AnyAtom, Scope?]>();\n  const implicit = new WeakMap<AnyAtom, [AnyAtom, Scope?]>();\n  type ScopeMap = WeakMap<AnyAtom, [AnyAtom, Scope?]>;\n  const inherited = new WeakMap<Scope | GlobalScopeKey, ScopeMap>();\n\n  const currentScope: Scope = {\n    getAtom,\n    cleanup() {},\n    prepareWriteAtom(anAtom, originalAtom, implicitScope) {\n      if (\n        originalAtom.read === defaultRead &&\n        isWritableAtom(originalAtom) &&\n        isWritableAtom(anAtom) &&\n        originalAtom.write !== defaultWrite &&\n        currentScope !== implicitScope\n      ) {\n        // atom is writable with init and holds a value\n        // we need to preserve the value, so we don't want to copy the atom\n        // instead, we need to override write until the write is finished\n        const { write } = originalAtom;\n        anAtom.write = createScopedWrite(\n          originalAtom.write.bind(\n            originalAtom,\n          ) as (typeof originalAtom)['write'],\n          implicitScope,\n        );\n        return () => {\n          anAtom.write = write;\n        };\n      }\n      return undefined;\n    },\n  };\n\n  if (scopeName && process.env.NODE_ENV !== 'production') {\n    currentScope.name = scopeName;\n    currentScope.toString = toString;\n  }\n\n  // populate explicitly scoped atoms\n  for (const anAtom of atoms) {\n    explicit.set(anAtom, [cloneAtom(anAtom, currentScope), currentScope]);\n  }\n\n  const cleanupFamiliesSet = new Set<() => void>();\n  for (const atomFamily of atomFamilies) {\n    for (const param of atomFamily.getParams()) {\n      const anAtom = atomFamily(param);\n      if (!explicit.has(anAtom)) {\n        explicit.set(anAtom, [cloneAtom(anAtom, currentScope), currentScope]);\n      }\n    }\n    const cleanupFamily = atomFamily.unstable_listen((e) => {\n      if (e.type === 'CREATE' && !explicit.has(e.atom)) {\n        explicit.set(e.atom, [cloneAtom(e.atom, currentScope), currentScope]);\n      } else if (!atoms.has(e.atom)) {\n        explicit.delete(e.atom);\n      }\n    });\n    cleanupFamiliesSet.add(cleanupFamily);\n  }\n  currentScope.cleanup = combineVoidFunctions(\n    currentScope.cleanup,\n    ...Array.from(cleanupFamiliesSet),\n  );\n\n  /**\n   * Returns a scoped atom from the original atom.\n   * @param anAtom\n   * @param implicitScope the atom is implicitly scoped in the provided scope\n   * @returns the scoped atom and the scope of the atom\n   */\n  function getAtom<T extends AnyAtom>(\n    anAtom: T,\n    implicitScope?: Scope,\n  ): [T, Scope?] {\n    if (explicit.has(anAtom)) {\n      return explicit.get(anAtom) as [T, Scope];\n    }\n    if (implicitScope === currentScope) {\n      // dependencies of explicitly scoped atoms are implicitly scoped\n      // implicitly scoped atoms are only accessed by implicit and explicit scoped atoms\n      if (!implicit.has(anAtom)) {\n        implicit.set(anAtom, [cloneAtom(anAtom, implicitScope), implicitScope]);\n      }\n      return implicit.get(anAtom) as [T, Scope];\n    }\n    const scopeKey = implicitScope ?? globalScopeKey;\n    if (parentScope) {\n      // inherited atoms are copied so they can access scoped atoms\n      // but they are not explicitly scoped\n      // dependencies of inherited atoms first check if they are explicitly scoped\n      // otherwise they use their original scope's atom\n      if (!inherited.get(scopeKey)?.has(anAtom)) {\n        const [ancestorAtom, explicitScope] = parentScope.getAtom(\n          anAtom,\n          implicitScope,\n        );\n        setInheritedAtom(\n          inheritAtom(ancestorAtom, anAtom, explicitScope),\n          anAtom,\n          implicitScope,\n          explicitScope,\n        );\n      }\n      return inherited.get(scopeKey)!.get(anAtom) as [T, Scope];\n    }\n    if (!inherited.get(scopeKey)?.has(anAtom)) {\n      // non-primitive atoms may need to access scoped atoms\n      // so we need to create a copy of the atom\n      setInheritedAtom(inheritAtom(anAtom, anAtom), anAtom);\n    }\n    return inherited.get(scopeKey)!.get(anAtom) as [T, Scope?];\n  }\n\n  function setInheritedAtom<T extends AnyAtom>(\n    scopedAtom: T,\n    originalAtom: T,\n    implicitScope?: Scope,\n    explicitScope?: Scope,\n  ) {\n    const scopeKey = implicitScope ?? globalScopeKey;\n    if (!inherited.has(scopeKey)) {\n      inherited.set(scopeKey, new WeakMap());\n    }\n    inherited.get(scopeKey)!.set(\n      originalAtom,\n      [\n        scopedAtom, //\n        explicitScope,\n      ].filter(Boolean) as [T, Scope?],\n    );\n  }\n\n  /**\n   * @returns a copy of the atom for derived atoms or the original atom for primitive and writable atoms\n   */\n  function inheritAtom<T>(\n    anAtom: Atom<T>,\n    originalAtom: Atom<T>,\n    implicitScope?: Scope,\n  ) {\n    if (originalAtom.read !== defaultRead) {\n      return cloneAtom(originalAtom, implicitScope);\n    }\n    return anAtom;\n  }\n\n  /**\n   * @returns a scoped copy of the atom\n   */\n  function cloneAtom<T>(originalAtom: Atom<T>, implicitScope?: Scope) {\n    // avoid reading `init` to preserve lazy initialization\n    const scopedAtom: Atom<T> = Object.create(\n      Object.getPrototypeOf(originalAtom),\n      Object.getOwnPropertyDescriptors(originalAtom),\n    );\n\n    if (scopedAtom.read !== defaultRead) {\n      scopedAtom.read = createScopedRead<typeof scopedAtom>(\n        originalAtom.read.bind(originalAtom),\n        implicitScope,\n      );\n    }\n\n    if (\n      isWritableAtom(scopedAtom) &&\n      isWritableAtom(originalAtom) &&\n      scopedAtom.write !== defaultWrite\n    ) {\n      scopedAtom.write = createScopedWrite(\n        originalAtom.write.bind(originalAtom),\n        implicitScope,\n      );\n    }\n\n    return scopedAtom;\n  }\n\n  function createScopedRead<T extends Atom<unknown>>(\n    read: T['read'],\n    implicitScope?: Scope,\n  ): T['read'] {\n    return function scopedRead(get, opts) {\n      return read(\n        function scopedGet(a) {\n          const [scopedAtom] = getAtom(a, implicitScope);\n          return get(scopedAtom);\n        }, //\n        opts,\n      );\n    };\n  }\n\n  function createScopedWrite<T extends AnyWritableAtom>(\n    write: T['write'],\n    implicitScope?: Scope,\n  ): T['write'] {\n    return function scopedWrite(get, set, ...args) {\n      return write(\n        function scopedGet(a) {\n          const [scopedAtom] = getAtom(a, implicitScope);\n          return get(scopedAtom);\n        },\n        function scopedSet(a, ...v) {\n          const [scopedAtom] = getAtom(a, implicitScope);\n          return set(scopedAtom, ...v);\n        },\n        ...args,\n      );\n    };\n  }\n\n  return currentScope;\n}\n\nfunction isWritableAtom(anAtom: AnyAtom): anAtom is AnyWritableAtom {\n  return 'write' in anAtom;\n}\n\nconst { read: defaultRead, write: defaultWrite } = atom<unknown>(null);\n\nfunction toString(this: { name: string }) {\n  return this.name;\n}\n\nfunction combineVoidFunctions(...fns: (() => void)[]) {\n  return function combinedFunctions() {\n    for (const fn of fns) {\n      fn();\n    }\n  };\n}\n","import type { Store, Scope } from './types';\n\nfunction PatchedStore() {}\n\n/**\n * @returns a patched store that intercepts get and set calls to apply the scope\n */\nexport function createPatchedStore(baseStore: Store, scope: Scope): Store {\n  const store: Store = {\n    ...baseStore,\n    get(anAtom, ...args) {\n      const [scopedAtom] = scope.getAtom(anAtom);\n      return baseStore.get(scopedAtom, ...args);\n    },\n    set(anAtom, ...args) {\n      const [scopedAtom, implicitScope] = scope.getAtom(anAtom);\n      const restore = scope.prepareWriteAtom(scopedAtom, anAtom, implicitScope);\n      try {\n        return baseStore.set(scopedAtom, ...args);\n      } finally {\n        restore?.();\n      }\n    },\n    sub(anAtom, ...args) {\n      const [scopedAtom] = scope.getAtom(anAtom);\n      return baseStore.sub(scopedAtom, ...args);\n    },\n    // TODO: update this patch to support devtools\n  };\n  return Object.assign(Object.create(PatchedStore.prototype), store);\n}\n\n/**\n * @returns true if the current scope is the first descendant scope under Provider\n */\nexport function isTopLevelScope(parentStore: Store) {\n  return !(parentStore instanceof PatchedStore);\n}\n","import { Provider, useStore } from 'jotai/react';\nimport {\n  type EffectCallback,\n  createContext,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n  type PropsWithChildren,\n} from 'react';\nimport { createScope } from './scope';\nimport type { AnyAtom, AnyAtomFamily, Store, Scope } from './types';\nimport { createPatchedStore, isTopLevelScope } from './patchedStore';\n\nconst ScopeContext = createContext<{\n  scope: Scope | undefined;\n  baseStore: Store | undefined;\n}>({ scope: undefined, baseStore: undefined });\n\nexport function ScopeProvider({\n  atoms,\n  atomFamilies,\n  children,\n  debugName,\n}: PropsWithChildren<{\n  atoms: Iterable<AnyAtom>;\n  atomFamilies?: Iterable<AnyAtomFamily>;\n  debugName?: string;\n}>): JSX.Element;\nexport function ScopeProvider({\n  atoms,\n  atomFamilies,\n  children,\n  debugName,\n}: PropsWithChildren<{\n  atoms?: Iterable<AnyAtom>;\n  atomFamilies: Iterable<AnyAtomFamily>;\n  debugName?: string;\n}>): JSX.Element;\nexport function ScopeProvider({\n  atoms,\n  atomFamilies,\n  children,\n  debugName,\n}: PropsWithChildren<{\n  atoms?: Iterable<AnyAtom>;\n  atomFamilies?: Iterable<AnyAtomFamily>;\n  debugName?: string;\n}>) {\n  const parentStore: Store = useStore();\n  let { scope: parentScope, baseStore = parentStore } =\n    useContext(ScopeContext);\n  // if this ScopeProvider is the first descendant scope under Provider then it is the top level scope\n  // https://github.com/jotaijs/jotai-scope/pull/33#discussion_r1604268003\n  if (isTopLevelScope(parentStore)) {\n    parentScope = undefined;\n    baseStore = parentStore;\n  }\n\n  // atomSet is used to detect if the atoms prop has changed.\n  const atomSet = new Set(atoms);\n  const atomFamilySet = new Set(atomFamilies);\n\n  function initialize() {\n    const scope = createScope(atomSet, atomFamilySet, parentScope, debugName);\n    return {\n      patchedStore: createPatchedStore(baseStore, scope),\n      scopeContext: { scope, baseStore },\n      hasChanged(current: {\n        baseStore: Store;\n        parentScope: Scope | undefined;\n        atomSet: Set<AnyAtom>;\n        atomFamilySet: Set<AnyAtomFamily>;\n      }) {\n        return (\n          parentScope !== current.parentScope ||\n          baseStore !== current.baseStore ||\n          !isEqualSet(atomSet, current.atomSet) ||\n          !isEqualSet(atomFamilySet, current.atomFamilySet)\n        );\n      },\n    };\n  }\n\n  const [state, setState] = useState(initialize);\n  const { hasChanged, scopeContext, patchedStore } = state;\n  if (hasChanged({ parentScope, atomSet, atomFamilySet, baseStore })) {\n    scopeContext.scope?.cleanup();\n    setState(initialize);\n  }\n  const { cleanup } = scopeContext.scope;\n  useEvent(() => cleanup, []);\n  return (\n    <ScopeContext.Provider value={scopeContext}>\n      <Provider store={patchedStore}>{children}</Provider>\n    </ScopeContext.Provider>\n  );\n}\n\nfunction isEqualSet(a: Set<unknown>, b: Set<unknown>) {\n  return a === b || (a.size === b.size && Array.from(a).every((v) => b.has(v)));\n}\n\nfunction useEvent(fn: EffectCallback, deps: unknown[]) {\n  const ref = useRef(fn);\n  ref.current = fn;\n  useEffect(() => ref.current(), deps);\n}\n"],"names":["createIsolation","StoreContext","createContext","Provider","store","initialValues","children","storeRef","useRef","current","createStore","useHydrateAtoms","_jsx","value","useStore","options","useContext","Error","useStoreOrig","_extends","useAtom","anAtom","useAtomOrig","useAtomValue","useAtomValueOrig","useSetAtom","useSetAtomOrig","globalScopeKey","process","env","NODE_ENV","name","toString","createScope","atoms","atomFamilies","parentScope","scopeName","explicit","WeakMap","implicit","inherited","currentScope","getAtom","cleanup","prepareWriteAtom","originalAtom","implicitScope","read","defaultRead","isWritableAtom","write","defaultWrite","createScopedWrite","bind","undefined","set","cloneAtom","cleanupFamiliesSet","Set","atomFamily","param","getParams","has","cleanupFamily","unstable_listen","e","type","atom","delete","add","combineVoidFunctions","Array","from","_inherited$get2","get","scopeKey","_inherited$get","ancestorAtom","explicitScope","setInheritedAtom","inheritAtom","scopedAtom","filter","Boolean","Object","create","getPrototypeOf","getOwnPropertyDescriptors","createScopedRead","scopedRead","opts","scopedGet","a","scopedWrite","args","scopedSet","v","fns","combinedFunctions","fn","PatchedStore","createPatchedStore","baseStore","scope","restore","sub","assign","prototype","isTopLevelScope","parentStore","ScopeContext","ScopeProvider","debugName","atomSet","atomFamilySet","initialize","patchedStore","scopeContext","hasChanged","isEqualSet","state","setState","useState","_scopeContext$scope","useEvent","b","size","every","deps","ref","useEffect"],"mappings":"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"}